<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Pastel Merge Drop</title>
  <style>
    :root{
      --bg1:#cfe9ff; /* æµ…è“ */
      --bg2:#f7d6ff; /* æµ…ç²‰ç´« */
      --bg3:#d9d6ff; /* æµ…ç´« */
      --panel: rgba(255,255,255,.55);
      --text: #2b2b3a;
      --line:#ff5a7a;
    }
    html,body{ height:100%; margin:0; font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    body{
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 900px at 20% 10%, var(--bg1), transparent 60%),
                  radial-gradient(900px 900px at 80% 20%, var(--bg2), transparent 55%),
                  radial-gradient(1000px 900px at 50% 90%, var(--bg3), transparent 60%),
                  linear-gradient(135deg, #fef6ff, #f3fbff);
      overflow:hidden;
    }
    .wrap{
      width:min(520px, 96vw);
      height:min(820px, 96vh);
      position:relative;
      border-radius:28px;
      box-shadow: 0 18px 60px rgba(20, 20, 60, .18);
      background: linear-gradient(180deg, rgba(255,255,255,.55), rgba(255,255,255,.25));
      backdrop-filter: blur(10px);
      overflow:hidden;
      touch-action: manipulation;
    }
    #game{ width:100%; height:100%; display:block; }
    .hud{
      position:absolute; left:14px; right:14px; top:12px;
      display:flex; gap:10px; align-items:stretch; justify-content:space-between;
      pointer-events:none;
    }
    .card{
      padding:10px 12px;
      border-radius:18px;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.55);
      box-shadow: 0 10px 30px rgba(20, 20, 60, .10);
      color: var(--text);
      display:flex; align-items:center; gap:10px;
      min-width: 150px;
    }
    .card small{ opacity:.75; display:block; line-height:1.2; }
    .card b{ font-size:18px; }
    .btnRow{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center;
    }
    .btn{
      pointer-events:auto;
      user-select:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:18px;
      background: linear-gradient(135deg, rgba(255,255,255,.65), rgba(255,255,255,.35));
      border: 1px solid rgba(255,255,255,.7);
      box-shadow: 0 10px 30px rgba(20, 20, 60, .10);
      color: var(--text);
      display:flex; align-items:center; gap:8px;
      transition: transform .12s ease;
      font-weight:600;
    }
    .btn:active{ transform: scale(.98); }

    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(255,255,255,.45);
      backdrop-filter: blur(8px);
    }
    .modal{
      width:min(360px, 86%);
      border-radius:26px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(255,255,255,.8);
      box-shadow: 0 22px 70px rgba(20,20,60,.18);
      padding:18px 16px;
      text-align:center;
      color: var(--text);
    }
    .modal h2{ margin:6px 0 6px; font-size:20px; }
    .modal p{ margin:6px 0 14px; opacity:.85; }
    .modal .row{ display:flex; gap:10px; justify-content:center; }
    .modal .row .btn{ pointer-events:auto; }

    /* å°å±æ›´èˆ’æœä¸€ç‚¹ */
    @media (max-width: 420px){
      .card{ min-width: 140px; }
      .btn{ padding:9px 10px; border-radius:16px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="card">
        <div>
          <small>Score</small>
          <b id="score">0</b>
        </div>
        <div style="width:1px;height:28px;background:rgba(0,0,0,.08)"></div>
        <div>
          <small>Best</small>
          <b id="best">0</b>
        </div>
      </div>

      <div class="btnRow">
        <div class="btn" id="muteBtn" title="Mute">ğŸ”Š</div>
        <div class="btn" id="restartBtn" title="Restart">ğŸ”„ Restart</div>
      </div>
    </div>

    <div class="overlay" id="over">
      <div class="modal">
        <div style="font-size:42px; line-height:1">ğŸ¥º</div>
        <h2>Game Over</h2>
        <p>ä½ çš„åˆ†æ•°ï¼š<b id="finalScore">0</b></p>
        <div class="row">
          <div class="btn" id="restartBtn2">å†æ¥ä¸€å±€</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Matter.jsï¼šç¨³å®š CDN -->
  <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
    (() => {
      if (!window.Matter) {
        alert("Matter.jsï¼ˆç‰©ç†å¼•æ“ï¼‰æ²¡åŠ è½½æˆåŠŸï¼Œæ‰€ä»¥æ— æ³•æ‰è½ã€‚\n\nå¯èƒ½åŸå› ï¼šç½‘ç»œ/æ‹¦æˆªæ’ä»¶æŒ¡ä½äº†å¤–é“¾è„šæœ¬ã€‚\nè§£å†³ï¼šæ¢ç½‘ç»œã€å…³å¹¿å‘Šæ‹¦æˆªï¼Œæˆ–æˆ‘ä¹Ÿå¯ä»¥ç»™ä½ ç¦»çº¿ç‰ˆæœ¬ã€‚");
        return;
      }

      const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

      const canvas = document.getElementById('game');
      const wrap = document.querySelector('.wrap');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const overEl = document.getElementById('over');
      const finalScoreEl = document.getElementById('finalScore');
      const restartBtn = document.getElementById('restartBtn');
      const restartBtn2 = document.getElementById('restartBtn2');
      const muteBtn = document.getElementById('muteBtn');

      function getSize(){
        const r = wrap.getBoundingClientRect();
        return { w: Math.floor(r.width), h: Math.floor(r.height) };
      }

      let { w: W, h: H } = getSize();
      canvas.width = W * devicePixelRatio;
      canvas.height = H * devicePixelRatio;
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";

      // === Pastel levels ===
      const LEVELS_BASE = [
        { label:"ğŸ«§", color:"#bfe7ff", r:18, score: 1 },
        { label:"ğŸ¬", color:"#ffd1ec", r:24, score: 3 },
        { label:"ğŸ§", color:"#dcd6ff", r:30, score: 8 },
        { label:"ğŸ‘", color:"#ffd7c2", r:36, score: 18 },
        { label:"ğŸ“", color:"#ffc1d6", r:44, score: 35 },
        { label:"ğŸ‡", color:"#d3c1ff", r:52, score: 65 },
        { label:"ğŸ‰", color:"#b8f0d6", r:62, score: 110 },
        { label:"ğŸŒŸ", color:"#fff2b8", r:74, score: 180 },
      ];

      // å±å¹•è‡ªé€‚åº”ï¼šå°å±ç¨å¾®ç¼©ä¸€ä¸¢ä¸¢ï¼Œå¤§å±ç¨å¾®æ”¾ä¸€ç‚¹ç‚¹
      function scaleFactor(){
        const f = W / 430;
        return Math.max(0.86, Math.min(1.08, f));
      }

      let LEVELS = [];
      let textures = [];

      function rebuildLevels(){
        const s = scaleFactor();
        LEVELS = LEVELS_BASE.map(l => ({
          ...l,
          r: Math.round(l.r * s)
        }));
        textures = LEVELS.map((_, i) => makeTexture(i));
      }

      function makeTexture(levelIndex){
        const lv = LEVELS[levelIndex];
        const size = Math.ceil(lv.r * 2.35);
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const ctx = c.getContext('2d');

        const grd = ctx.createRadialGradient(size*0.45, size*0.35, size*0.15, size*0.5, size*0.55, size*0.55);
        grd.addColorStop(0, "rgba(255,255,255,.95)");
        grd.addColorStop(1, lv.color);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(size/2, size/2, size*0.46, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,.55)";
        ctx.beginPath();
        ctx.arc(size*0.38, size*0.35, size*0.12, 0, Math.PI*2);
        ctx.fill();

        ctx.lineWidth = Math.max(2, size*0.03);
        ctx.strokeStyle = "rgba(255,255,255,.75)";
        ctx.beginPath();
        ctx.arc(size/2, size/2, size*0.46, 0, Math.PI*2);
        ctx.stroke();

        ctx.font = `${Math.floor(size*0.46)}px ui-rounded, system-ui, Apple Color Emoji, Segoe UI Emoji`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(35,35,55,.90)";
        ctx.fillText(lv.label, size/2, size/2 + size*0.03);

        return c.toDataURL("image/png");
      }

      function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
      function randStartLevel(){ return Math.floor(Math.random() * 3); }

      // === Audio (Web Audio) ===
      let audioCtx = null;
      let muted = false;
      function ensureAudio(){
        if(muted) return null;
        if(!audioCtx){
          const AC = window.AudioContext || window.webkitAudioContext;
          audioCtx = AC ? new AC() : null;
        }
        if(audioCtx && audioCtx.state === "suspended"){
          audioCtx.resume().catch(()=>{});
        }
        return audioCtx;
      }

      function playPop(){
        const ctx = ensureAudio();
        if(!ctx) return;
        const t = ctx.currentTime;

        // ä½é¢‘ "å•µ"
        const o1 = ctx.createOscillator();
        const g1 = ctx.createGain();
        o1.type = "sine";
        o1.frequency.setValueAtTime(220, t);
        o1.frequency.exponentialRampToValueAtTime(120, t + 0.09);
        g1.gain.setValueAtTime(0.0001, t);
        g1.gain.exponentialRampToValueAtTime(0.22, t + 0.01);
        g1.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
        o1.connect(g1).connect(ctx.destination);
        o1.start(t);
        o1.stop(t + 0.13);

        // é«˜é¢‘ "å®"
        const o2 = ctx.createOscillator();
        const g2 = ctx.createGain();
        o2.type = "triangle";
        o2.frequency.setValueAtTime(880, t);
        o2.frequency.exponentialRampToValueAtTime(1200, t + 0.06);
        g2.gain.setValueAtTime(0.0001, t);
        g2.gain.exponentialRampToValueAtTime(0.10, t + 0.01);
        g2.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);
        o2.connect(g2).connect(ctx.destination);
        o2.start(t);
        o2.stop(t + 0.11);
      }

      muteBtn.addEventListener("click", ()=>{
        muted = !muted;
        muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";
      });

      // === Particles + Screen Shake ===
      const particles = [];
      let shakeTime = 0;
      let shakeAmp = 0;

      function spawnMergeFX(x, y, color){
        // ç²’å­
        const n = 22;
        for(let i=0;i<n;i++){
          const a = Math.random() * Math.PI * 2;
          const sp = 1.6 + Math.random() * 3.2;
          particles.push({
            x, y,
            vx: Math.cos(a)*sp,
            vy: Math.sin(a)*sp - 0.8,
            life: 420 + Math.random()*260,
            age: 0,
            r: 2 + Math.random()*3.5,
            color
          });
        }
        // è½»å¾®éœ‡åŠ¨
        shakeTime = 140;
        shakeAmp = 7;
      }

      function updateParticles(dt){
        for(let i=particles.length-1; i>=0; i--){
          const p = particles[i];
          p.age += dt;
          if(p.age >= p.life){
            particles.splice(i, 1);
            continue;
          }
          p.vy += 0.015 * dt; // gravity
          p.x += p.vx * (dt/16.67);
          p.y += p.vy * (dt/16.67);
          p.vx *= 0.985;
          p.vy *= 0.985;
        }
      }

      function drawParticles(ctx){
        for(const p of particles){
          const t = p.age / p.life;
          const a = 1 - t;
          ctx.globalAlpha = Math.max(0, a);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      // === Game state ===
      let engine, runner, render;
      let score = 0;
      let best = Number(localStorage.getItem('pastel_merge_best') || 0);
      bestEl.textContent = best;

      let canDrop = true;
      let nextLevel = 0;
      let pointerX = W * 0.5;

      // è‡ªé€‚åº”å±é™©çº¿ï¼šæ›´è´´è¿‘é¡¶éƒ¨ï¼ˆæ‰‹æœºä¸ä¼šè·‘åˆ°ä¸­é—´ï¼‰
      let dangerY = 0;
      function computeDangerY(){
        dangerY = Math.round(Math.max(90, H * 0.18));
      }

      let dangerTimer = 0;
      const DANGER_DURATION = 1050;

      const MERGE_COOLDOWN = 140;
      const recentlyMerged = new Set();

      function setScore(val){
        score = val;
        scoreEl.textContent = score;
        if(score > best){
          best = score;
          bestEl.textContent = best;
          localStorage.setItem('pastel_merge_best', String(best));
        }
      }

      function setSpriteScale(body, levelIndex){
        const lv = LEVELS[levelIndex];
        const img = new Image();
        img.src = textures[levelIndex];
        img.onload = () => {
          const target = lv.r * 2.3;
          body.render.sprite.xScale = target / img.width;
          body.render.sprite.yScale = target / img.height;
        };
      }

      function makeBall(levelIndex, x, y, fromMerge=false){
        const lv = LEVELS[levelIndex];
        const ball = Bodies.circle(x, y, lv.r, {
          restitution: 0.18,
          friction: 0.02,
          frictionAir: 0.010,
          density: 0.0012,
          render: { sprite: { texture: textures[levelIndex], xScale: 1, yScale: 1 } }
        });

        ball.plugin = ball.plugin || {};
        ball.plugin.mergeLevel = levelIndex;
        ball.plugin.merging = false;

        setSpriteScale(ball, levelIndex);

        if(fromMerge){
          const kick = (Math.random()*2 - 1) * 0.8;
          Body.applyForce(ball, ball.position, { x: kick * 0.0009, y: -0.0010 });
        }

        World.add(engine.world, ball);
        return ball;
      }

      function drop(){
        if(!canDrop) return;
        canDrop = false;

        // æ‰‹æœº/æµè§ˆå™¨ï¼šå¿…é¡»å…ˆäº¤äº’æ‰èƒ½å‘å£°ï¼Œæ‰€ä»¥åœ¨ drop æ—¶ç¡®ä¿ audio å¯ç”¨
        ensureAudio();

        const lv = LEVELS[nextLevel];
        const x = clamp(pointerX, lv.r + 18, W - lv.r - 18);
        const y = Math.max(78, dangerY - 18); // æ›´è´´è¿‘ä¸Šæ–¹ã€å¥½è§‚å¯Ÿ

        makeBall(nextLevel, x, y, false);
        nextLevel = randStartLevel();

        setTimeout(() => canDrop = true, 230);
      }

      function gameOver(){
        overEl.style.display = "flex";
        finalScoreEl.textContent = score;
        canDrop = false;
      }

      function restart(){
        overEl.style.display = "none";
        setScore(0);
        nextLevel = randStartLevel();
        canDrop = true;
        dangerTimer = 0;
        particles.length = 0;

        const bodies = Composite.allBodies(engine.world);
        for(const b of bodies){
          if(!b.isStatic) World.remove(engine.world, b);
        }
      }

      function build(){
        const s = getSize();
        W = s.w; H = s.h;
        computeDangerY();
        rebuildLevels();

        canvas.width = W * devicePixelRatio;
        canvas.height = H * devicePixelRatio;
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";

        engine = Engine.create();
        engine.gravity.y = 1.05;

        render = Render.create({
          canvas,
          engine,
          options: {
            width: W,
            height: H,
            wireframes: false,
            background: "transparent",
            pixelRatio: devicePixelRatio
          }
        });

        runner = Runner.create();

        // âœ… åœ°é¢æŠ¬é«˜ï¼šè®©å †å æ›´é ä¸Šã€æ›´å¥½çœ‹
        const thickness = 60;
        const floorY = H - 26; // æŠ¬é«˜åœ°é¢ï¼ˆä¸å†å †åˆ°æœ€åº•ï¼‰
        const floor = Bodies.rectangle(W/2, floorY + thickness/2, W + thickness*2, thickness, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });
        const left  = Bodies.rectangle(-thickness/2, H/2, thickness, H, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });
        const right = Bodies.rectangle(W + thickness/2, H/2, thickness, H, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });

        [floor,left,right].forEach(b => { b.friction=0.02; b.restitution=0.15; });
        World.add(engine.world, [floor, left, right]);

        // è‡ªå®šä¹‰ç»˜åˆ¶ï¼šå±é™©çº¿ + next ghost + ç²’å­ + éœ‡åŠ¨
        let lastFrameT = performance.now();
        Events.on(render, "afterRender", () => {
          const now = performance.now();
          const dt = now - lastFrameT;
          lastFrameT = now;

          const ctx = render.context;

          // === screen shakeï¼ˆè½»å¾®ï¼‰===
          if(shakeTime > 0){
            shakeTime -= dt;
            const k = Math.max(0, shakeTime / 140);
            const amp = shakeAmp * k;
            const ox = (Math.random()*2 - 1) * amp;
            const oy = (Math.random()*2 - 1) * amp;
            ctx.save();
            ctx.translate(ox, oy);
            ctx.restore();
          }

          // æ³¨æ„ï¼šä¸è¦å†æ‰‹åŠ¨ ctx.scale(dpr,dpr)ï¼ŒRender å·²å¤„ç† pixelRatio
          // æˆ‘ä»¬ç›´æ¥æŒ‰â€œé€»è¾‘åƒç´ â€ç”»ï¼ˆRender çš„ ctx å·²ç»åŒ¹é… options.width/height çš„åæ ‡ç³»ï¼‰
          // === danger line ===
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(18, dangerY);
          ctx.lineTo(W-18, dangerY);
          ctx.setLineDash([8, 8]);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255, 90, 122, .55)";
          ctx.stroke();
          ctx.setLineDash([]);

          // danger tint
          if(dangerTimer > 0){
            const t = clamp(dangerTimer / DANGER_DURATION, 0, 1);
            ctx.fillStyle = `rgba(255, 90, 122, ${0.08 + 0.22*t})`;
            ctx.fillRect(0, 0, W, dangerY);
          }

          // next preview ghostï¼ˆæ›´é è¿‘é¡¶éƒ¨ï¼‰
          const lv = LEVELS[nextLevel];
          const x = clamp(pointerX, lv.r + 18, W - lv.r - 18);
          const y = Math.max(58, dangerY - 52);

          ctx.globalAlpha = 0.62;
          const img = new Image();
          img.src = textures[nextLevel];

          ctx.beginPath();
          ctx.arc(x, y + lv.r + 10, lv.r * 0.9, 0, Math.PI*2);
          ctx.fillStyle = "rgba(30,30,60,.08)";
          ctx.fill();

          ctx.drawImage(img, x - lv.r*1.15, y - lv.r*1.15, lv.r*2.3, lv.r*2.3);
          ctx.globalAlpha = 1;

          // particles
          updateParticles(dt);
          drawParticles(ctx);

          ctx.restore();
        });

        // åˆæˆé€»è¾‘
        Events.on(engine, "collisionStart", (ev) => {
          for (const pair of ev.pairs) {
            const a = pair.bodyA;
            const b = pair.bodyB;

            if (a.plugin?.mergeLevel === undefined) continue;
            if (b.plugin?.mergeLevel === undefined) continue;
            if (a.plugin.mergeLevel !== b.plugin.mergeLevel) continue;
            if (a.plugin.merging || b.plugin.merging) continue;

            const idKey = a.id < b.id ? `${a.id}-${b.id}` : `${b.id}-${a.id}`;
            if (recentlyMerged.has(idKey)) continue;
            recentlyMerged.add(idKey);
            setTimeout(()=>recentlyMerged.delete(idKey), MERGE_COOLDOWN);

            const level = a.plugin.mergeLevel;
            if (level >= LEVELS.length - 1) continue;

            a.plugin.merging = true;
            b.plugin.merging = true;

            const pos = { x: (a.position.x + b.position.x) / 2, y: (a.position.y + b.position.y) / 2 };

            World.remove(engine.world, a);
            World.remove(engine.world, b);

            setScore(score + LEVELS[level].score);

            const nl = level + 1;
            const newBody = makeBall(nl, pos.x, pos.y, true);

            // pop
            Body.scale(newBody, 1.16, 1.16);
            setTimeout(() => {
              if (!newBody.isSleeping) Body.scale(newBody, 1/1.16, 1/1.16);
            }, 115);

            // FX + Sound
            spawnMergeFX(pos.x, pos.y, LEVELS[nl].color);
            playPop();
          }
        });

        // danger check
        let lastT = performance.now();
        Events.on(engine, "beforeUpdate", () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;

          if (overEl.style.display === "flex") return;

          const bodies = Composite.allBodies(engine.world).filter(b => !b.isStatic);
          let inDanger = false;

          for(const b of bodies){
            if(b.plugin?.mergeLevel === undefined) continue;
            const r = b.circleRadius || 0;
            const top = b.position.y - r;
            if(top < dangerY){ inDanger = true; break; }
          }

          if(inDanger){
            dangerTimer += dt;
            if(dangerTimer >= DANGER_DURATION) gameOver();
          }else{
            dangerTimer = Math.max(0, dangerTimer - dt*1.4);
          }
        });

        Render.run(render);
        Runner.run(runner, engine);

        setScore(0);
        nextLevel = randStartLevel();
        pointerX = W * 0.5;
        dangerTimer = 0;
        canDrop = true;
        particles.length = 0;
      }

      function setPointerFromClientX(clientX){
        const rect = wrap.getBoundingClientRect();
        pointerX = clientX - rect.left;
      }

      // é¼ æ ‡ / è§¦å±è¾“å…¥
      wrap.addEventListener("mousemove", (e)=> setPointerFromClientX(e.clientX));
      wrap.addEventListener("click", (e)=>{
        if (e.target && (e.target.id === "restartBtn" || e.target.closest?.("#restartBtn") || e.target.id === "muteBtn" || e.target.closest?.("#muteBtn"))) return;
        if (overEl.style.display === "flex") return;
        drop();
      });

      wrap.addEventListener("touchstart", (e)=>{
        if(e.touches?.[0]) setPointerFromClientX(e.touches[0].clientX);
      }, {passive:true});
      wrap.addEventListener("touchmove", (e)=>{
        if(e.touches?.[0]) setPointerFromClientX(e.touches[0].clientX);
      }, {passive:true});
      wrap.addEventListener("touchend", ()=>{
        if (overEl.style.display === "flex") return;
        drop();
      }, {passive:true});

      window.addEventListener("keydown", (e)=>{
        if(e.code === "Space" || e.key === " "){
          e.preventDefault();
          if (overEl.style.display === "flex") return;
          drop();
        }
        if(e.key === "r" || e.key === "R"){
          restart();
        }
        if(e.key === "m" || e.key === "M"){
          muted = !muted;
          muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";
        }
      });

      restartBtn.addEventListener("click", restart);
      restartBtn2.addEventListener("click", restart);

      // Resizeï¼šé‡å»ºï¼ˆæ‰‹æœºæ—‹è½¬/åœ°å€æ å˜åŒ–ä¹Ÿä¼šè§¦å‘ï¼‰
      let resizeTimer = null;
      window.addEventListener("resize", ()=>{
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{
          const s = getSize();
          // åœæ­¢æ—§çš„
          if(render) Render.stop(render);
          if(runner) Runner.stop(runner);
          if(engine){
            World.clear(engine.world, false);
            Engine.clear(engine);
          }
          // é‡æ–°å»º
          build();
        }, 120);
      });

      // Boot
      build();
    })();
  </script>
</body>
</html>
