<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Pastel Merge Drop</title>
  <style>
    :root{
      --bg1:#cfe9ff; /* æµ…è“ */
      --bg2:#f7d6ff; /* æµ…ç²‰ç´« */
      --bg3:#d9d6ff; /* æµ…ç´« */
      --panel: rgba(255,255,255,.55);
      --panel2: rgba(255,255,255,.35);
      --text: #2b2b3a;
      --line:#ff5a7a;
    }
    html,body{ height:100%; margin:0; font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    body{
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 900px at 20% 10%, var(--bg1), transparent 60%),
                  radial-gradient(900px 900px at 80% 20%, var(--bg2), transparent 55%),
                  radial-gradient(1000px 900px at 50% 90%, var(--bg3), transparent 60%),
                  linear-gradient(135deg, #fef6ff, #f3fbff);
      overflow:hidden;
    }
    .wrap{
      width:min(520px, 96vw);
      height:min(820px, 96vh);
      position:relative;
      border-radius:28px;
      box-shadow: 0 18px 60px rgba(20, 20, 60, .18);
      background: linear-gradient(180deg, rgba(255,255,255,.55), rgba(255,255,255,.25));
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    #game{ width:100%; height:100%; display:block; }
    .hud{
      position:absolute; left:14px; right:14px; top:12px;
      display:flex; gap:10px; align-items:stretch; justify-content:space-between;
      pointer-events:none;
    }
    .card{
      padding:10px 12px;
      border-radius:18px;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.55);
      box-shadow: 0 10px 30px rgba(20, 20, 60, .10);
      color: var(--text);
      display:flex; align-items:center; gap:10px;
      min-width: 150px;
    }
    .card small{ opacity:.75; display:block; line-height:1.2; }
    .card b{ font-size:18px; }
    .btn{
      pointer-events:auto;
      user-select:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:18px;
      background: linear-gradient(135deg, rgba(255,255,255,.65), rgba(255,255,255,.35));
      border: 1px solid rgba(255,255,255,.7);
      box-shadow: 0 10px 30px rgba(20, 20, 60, .10);
      color: var(--text);
      display:flex; align-items:center; gap:8px;
      transition: transform .12s ease;
    }
    .btn:active{ transform: scale(.98); }
    .tips{
      position:absolute; left:14px; right:14px; bottom:12px;
      display:flex; justify-content:center;
      pointer-events:none;
    }
    .tips .pill{
      padding:10px 14px;
      border-radius:999px;
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,.55);
      color: rgba(43,43,58,.85);
      font-size:12.5px;
      box-shadow: 0 10px 30px rgba(20, 20, 60, .08);
    }
    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(255,255,255,.45);
      backdrop-filter: blur(8px);
    }
    .modal{
      width:min(360px, 86%);
      border-radius:26px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(255,255,255,.8);
      box-shadow: 0 22px 70px rgba(20,20,60,.18);
      padding:18px 16px;
      text-align:center;
      color: var(--text);
    }
    .modal h2{ margin:6px 0 6px; font-size:20px; }
    .modal p{ margin:6px 0 14px; opacity:.85; }
    .modal .row{ display:flex; gap:10px; justify-content:center; }
    .modal .row .btn{ pointer-events:auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="card">
        <div>
          <small>Score</small>
          <b id="score">0</b>
        </div>
        <div style="width:1px;height:28px;background:rgba(0,0,0,.08)"></div>
        <div>
          <small>Best</small>
          <b id="best">0</b>
        </div>
      </div>

      <div class="btn" id="restartBtn" title="Restart">
        ğŸ”„ <span style="font-weight:600">Restart</span>
      </div>
    </div>

    <div class="tips">
      <div class="pill">ç§»åŠ¨é¼ æ ‡/æ‰‹æŒ‡é€‰æ‹©è½ç‚¹ï¼Œç‚¹å‡»/ç©ºæ ¼æŠ•æ”¾ã€‚ä¸¤ä¸ªç›¸åŒä¼šåˆæˆ âœ¨</div>
    </div>

    <div class="overlay" id="over">
      <div class="modal">
        <div style="font-size:42px; line-height:1">ğŸ¥º</div>
        <h2>Game Over</h2>
        <p>ä½ çš„åˆ†æ•°ï¼š<b id="finalScore">0</b></p>
        <div class="row">
          <div class="btn" id="restartBtn2">å†æ¥ä¸€å±€</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Matter.jsï¼šæ›´ç¨³çš„ CDNï¼ˆunpkgï¼‰ -->
  <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
    (() => {
      // âœ… è‡ªæ£€ï¼šå¦‚æœ Matter.js æ²¡åŠ è½½æˆåŠŸï¼Œä¼šç›´æ¥æç¤ºä½ åŸå› 
      if (!window.Matter) {
        alert("Matter.jsï¼ˆç‰©ç†å¼•æ“ï¼‰æ²¡åŠ è½½æˆåŠŸï¼Œæ‰€ä»¥æ— æ³•æ‰è½ã€‚\n\nå¯èƒ½åŸå› ï¼šç½‘ç»œ/æ‹¦æˆªæ’ä»¶æŒ¡ä½äº†å¤–é“¾è„šæœ¬ã€‚\nè§£å†³ï¼šæ¢ç½‘ç»œã€å…³å¹¿å‘Šæ‹¦æˆªï¼Œæˆ–æˆ‘ä¹Ÿå¯ä»¥ç»™ä½ ç¦»çº¿ç‰ˆæœ¬ã€‚");
        return;
      }

      const {
        Engine, Render, Runner, World, Bodies, Body, Events, Composite
      } = Matter;

      const canvas = document.getElementById('game');
      const wrap = document.querySelector('.wrap');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const overEl = document.getElementById('over');
      const finalScoreEl = document.getElementById('finalScore');
      const restartBtn = document.getElementById('restartBtn');
      const restartBtn2 = document.getElementById('restartBtn2');

      function getSize(){
        const r = wrap.getBoundingClientRect();
        return { w: Math.floor(r.width), h: Math.floor(r.height) };
      }

      let { w: W, h: H } = getSize();
      canvas.width = W * devicePixelRatio;
      canvas.height = H * devicePixelRatio;
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";

      // å¯çˆ±ç­‰çº§ï¼ˆä½ ä¹‹åå¯ä»¥æŠŠ emoji æ›¿æ¢æˆä½ è‡ªå·±çš„å›¾ï¼‰
      const LEVELS = [
        { label:"ğŸ«§", color:"#bfe7ff", r:18, score: 1 },
        { label:"ğŸ¬", color:"#ffd1ec", r:24, score: 3 },
        { label:"ğŸ§", color:"#dcd6ff", r:30, score: 8 },
        { label:"ğŸ‘", color:"#ffd7c2", r:36, score: 18 },
        { label:"ğŸ“", color:"#ffc1d6", r:44, score: 35 },
        { label:"ğŸ‡", color:"#d3c1ff", r:52, score: 65 },
        { label:"ğŸ‰", color:"#b8f0d6", r:62, score: 110 },
        { label:"ğŸŒŸ", color:"#fff2b8", r:74, score: 180 },
      ];

      function makeTexture(levelIndex){
        const lv = LEVELS[levelIndex];
        const size = Math.ceil(lv.r * 2.35);
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const ctx = c.getContext('2d');

        const grd = ctx.createRadialGradient(size*0.45, size*0.35, size*0.15, size*0.5, size*0.55, size*0.55);
        grd.addColorStop(0, "rgba(255,255,255,.95)");
        grd.addColorStop(1, lv.color);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(size/2, size/2, size*0.46, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,.55)";
        ctx.beginPath();
        ctx.arc(size*0.38, size*0.35, size*0.12, 0, Math.PI*2);
        ctx.fill();

        ctx.lineWidth = Math.max(2, size*0.03);
        ctx.strokeStyle = "rgba(255,255,255,.75)";
        ctx.beginPath();
        ctx.arc(size/2, size/2, size*0.46, 0, Math.PI*2);
        ctx.stroke();

        ctx.font = `${Math.floor(size*0.46)}px ui-rounded, system-ui, Apple Color Emoji, Segoe UI Emoji`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(35,35,55,.90)";
        ctx.fillText(lv.label, size/2, size/2 + size*0.03);

        return c.toDataURL("image/png");
      }

      const textures = LEVELS.map((_, i) => makeTexture(i));

      function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
      function randStartLevel(){ return Math.floor(Math.random() * 3); }

      let engine, runner, render;
      let score = 0;
      let best = Number(localStorage.getItem('pastel_merge_best') || 0);
      bestEl.textContent = best;

      let canDrop = true;
      let nextLevel = randStartLevel();
      let pointerX = W * 0.5;

      let dangerY = 110;
      let dangerTimer = 0;
      const DANGER_DURATION = 1100;

      const MERGE_COOLDOWN = 140;
      const recentlyMerged = new Set();

      function setScore(val){
        score = val;
        scoreEl.textContent = score;
        if(score > best){
          best = score;
          bestEl.textContent = best;
          localStorage.setItem('pastel_merge_best', String(best));
        }
      }

      function setSpriteScale(body, levelIndex){
        const lv = LEVELS[levelIndex];
        const img = new Image();
        img.src = textures[levelIndex];
        img.onload = () => {
          const target = lv.r * 2.3;
          body.render.sprite.xScale = target / img.width;
          body.render.sprite.yScale = target / img.height;
        };
      }

      function makeBall(levelIndex, x, y, fromMerge=false){
        const lv = LEVELS[levelIndex];
        const ball = Bodies.circle(x, y, lv.r, {
          restitution: 0.18,
          friction: 0.02,
          frictionAir: 0.010,
          density: 0.0012,
          render: {
            sprite: { texture: textures[levelIndex], xScale: 1, yScale: 1 }
          }
        });

        ball.plugin = ball.plugin || {};
        ball.plugin.mergeLevel = levelIndex;
        ball.plugin.merging = false;

        setSpriteScale(ball, levelIndex);

        if(fromMerge){
          const kick = (Math.random()*2 - 1) * 0.8;
          Body.applyForce(ball, ball.position, { x: kick * 0.0009, y: -0.0010 });
        }

        World.add(engine.world, ball);
        return ball;
      }

      function drop(){
        if(!canDrop) return;
        canDrop = false;

        const lv = LEVELS[nextLevel];
        const x = clamp(pointerX, lv.r + 18, W - lv.r - 18);
        const y = 72;

        makeBall(nextLevel, x, y, false);
        nextLevel = randStartLevel();

        setTimeout(() => canDrop = true, 240);
      }

      function gameOver(){
        overEl.style.display = "flex";
        finalScoreEl.textContent = score;
        canDrop = false;
      }

      function restart(){
        overEl.style.display = "none";
        setScore(0);
        nextLevel = randStartLevel();
        canDrop = true;
        dangerTimer = 0;

        const bodies = Composite.allBodies(engine.world);
        for(const b of bodies){
          if(!b.isStatic){
            World.remove(engine.world, b);
          }
        }
      }

      function build(){
        const s = getSize();
        W = s.w; H = s.h;

        canvas.width = W * devicePixelRatio;
        canvas.height = H * devicePixelRatio;
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";

        engine = Engine.create();
        engine.gravity.y = 1.05;

        render = Render.create({
          canvas,
          engine,
          options: {
            width: W,
            height: H,
            wireframes: false,
            background: "transparent",
            pixelRatio: devicePixelRatio
          }
        });

        runner = Runner.create();

        const thickness = 60;
        const floor = Bodies.rectangle(W/2, H + thickness/2 - 6, W + thickness*2, thickness, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });
        const left  = Bodies.rectangle(-thickness/2, H/2, thickness, H, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });
        const right = Bodies.rectangle(W + thickness/2, H/2, thickness, H, { isStatic: true, render:{ fillStyle:"rgba(255,255,255,0)" } });

        [floor,left,right].forEach(b => { b.friction=0.02; b.restitution=0.15; });

        World.add(engine.world, [floor, left, right]);

        Events.on(render, "afterRender", () => {
          const ctx = render.context;
          ctx.save();
          ctx.scale(devicePixelRatio, devicePixelRatio);

          // danger line
          ctx.beginPath();
          ctx.moveTo(18, dangerY);
          ctx.lineTo(W-18, dangerY);
          ctx.setLineDash([8, 8]);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255, 90, 122, .55)";
          ctx.stroke();
          ctx.setLineDash([]);

          // danger tint
          if(dangerTimer > 0){
            const t = clamp(dangerTimer / DANGER_DURATION, 0, 1);
            ctx.fillStyle = `rgba(255, 90, 122, ${0.10 + 0.25*t})`;
            ctx.fillRect(0, 0, W, dangerY);
          }

          // next preview ghost
          const lv = LEVELS[nextLevel];
          const x = clamp(pointerX, lv.r + 18, W - lv.r - 18);
          const y = 64;

          ctx.globalAlpha = 0.65;
          const img = new Image();
          img.src = textures[nextLevel];

          ctx.beginPath();
          ctx.arc(x, y + lv.r + 10, lv.r * 0.9, 0, Math.PI*2);
          ctx.fillStyle = "rgba(30,30,60,.08)";
          ctx.fill();

          ctx.drawImage(img, x - lv.r*1.15, y - lv.r*1.15, lv.r*2.3, lv.r*2.3);
          ctx.globalAlpha = 1;

          ctx.restore();
        });

        Events.on(engine, "collisionStart", (ev) => {
          for (const pair of ev.pairs) {
            const a = pair.bodyA;
            const b = pair.bodyB;

            if (a.plugin?.mergeLevel === undefined) continue;
            if (b.plugin?.mergeLevel === undefined) continue;
            if (a.plugin.mergeLevel !== b.plugin.mergeLevel) continue;
            if (a.plugin.merging || b.plugin.merging) continue;

            const idKey = a.id < b.id ? `${a.id}-${b.id}` : `${b.id}-${a.id}`;
            if (recentlyMerged.has(idKey)) continue;
            recentlyMerged.add(idKey);
            setTimeout(()=>recentlyMerged.delete(idKey), MERGE_COOLDOWN);

            const level = a.plugin.mergeLevel;
            if (level >= LEVELS.length - 1) continue;

            a.plugin.merging = true;
            b.plugin.merging = true;

            const pos = { x: (a.position.x + b.position.x) / 2, y: (a.position.y + b.position.y) / 2 };

            World.remove(engine.world, a);
            World.remove(engine.world, b);

            setScore(score + LEVELS[level].score);

            const nl = level + 1;
            const newBody = makeBall(nl, pos.x, pos.y, true);

            Body.scale(newBody, 1.14, 1.14);
            setTimeout(() => {
              if (!newBody.isSleeping) Body.scale(newBody, 1/1.14, 1/1.14);
            }, 110);
          }
        });

        // danger check
        let lastT = performance.now();
        Events.on(engine, "beforeUpdate", () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;

          if (overEl.style.display === "flex") return;

          const bodies = Composite.allBodies(engine.world).filter(b => !b.isStatic);
          let inDanger = false;

          for(const b of bodies){
            if(b.plugin?.mergeLevel === undefined) continue;
            const r = b.circleRadius || 0;
            const top = b.position.y - r;
            if(top < dangerY){ inDanger = true; break; }
          }

          if(inDanger){
            dangerTimer += dt;
            if(dangerTimer >= DANGER_DURATION) gameOver();
          }else{
            dangerTimer = Math.max(0, dangerTimer - dt*1.3);
          }
        });

        Render.run(render);
        Runner.run(runner, engine);

        setScore(0);
        nextLevel = randStartLevel();
        pointerX = W * 0.5;
        dangerTimer = 0;
        canDrop = true;
      }

      // pointer
      function setPointerFromClientX(clientX){
        const rect = wrap.getBoundingClientRect();
        pointerX = clientX - rect.left;
      }

      wrap.addEventListener("mousemove", (e)=> setPointerFromClientX(e.clientX));
      wrap.addEventListener("click", (e)=>{
        if (e.target && (e.target.id === "restartBtn" || e.target.closest?.("#restartBtn"))) return;
        if (overEl.style.display === "flex") return;
        drop();
      });

      // touch
      wrap.addEventListener("touchstart", (e)=>{
        if(e.touches?.[0]) setPointerFromClientX(e.touches[0].clientX);
      }, {passive:true});
      wrap.addEventListener("touchmove", (e)=>{
        if(e.touches?.[0]) setPointerFromClientX(e.touches[0].clientX);
      }, {passive:true});
      wrap.addEventListener("touchend", ()=>{
        if (overEl.style.display === "flex") return;
        drop();
      }, {passive:true});

      window.addEventListener("keydown", (e)=>{
        if(e.code === "Space" || e.key === " "){
          e.preventDefault();
          if (overEl.style.display === "flex") return;
          drop();
        }
        if(e.key === "r" || e.key === "R"){
          restart();
        }
      });

      restartBtn.addEventListener("click", restart);
      restartBtn2.addEventListener("click", restart);

      window.addEventListener("resize", ()=>{
        const s = getSize();
        if(Math.abs(s.w - W) < 2 && Math.abs(s.h - H) < 2) return;

        Render.stop(render);
        Runner.stop(runner);
        World.clear(engine.world, false);
        Engine.clear(engine);
        build();
      });

      build();
    })();
  </script>
</body>
</html>
